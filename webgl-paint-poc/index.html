<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL Symmetry Paint PoC</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 30px;
      }
      .demo-link {
        display: block;
        background: #007bff;
        color: white;
        text-decoration: none;
        padding: 15px 30px;
        border-radius: 5px;
        text-align: center;
        font-size: 18px;
        margin: 20px 0;
        transition: background 0.3s;
      }
      .demo-link:hover {
        background: #0056b3;
      }
      .demo-button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 0 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .demo-button:hover {
        background: #0056b3;
      }
      .demo-button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .demo-section {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 20px;
        margin: 20px 0;
      }
      .stroke-item {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 5px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .stroke-item:hover {
        background: #e9ecef;
      }
      .stroke-item.selected {
        background: #007bff;
        color: white;
      }
      .info {
        background: #e7f3ff;
        border: 1px solid #b8daff;
        border-radius: 4px;
        padding: 15px;
        margin: 15px 0;
      }
      .status {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 15px;
        border-radius: 4px;
        margin: 20px 0;
      }
      #app {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      #paint-canvas {
        border: 2px solid #333;
        background-color: white;
        cursor: crosshair;
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>WebGL Symmetry Paint PoC</h1>
      

      <div class="demo-section" style="display: none;">
        <h2>Interactive Paint Canvas (1024x1024)</h2>
        <div style="text-align: center; margin: 20px 0;">
          <canvas id="paint-canvas" width="1024" height="1024" style="max-width: 100%; height: auto; border: 2px solid #ddd; border-radius: 4px; background: white; cursor: crosshair;"></canvas>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
          <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin: 10px 0;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label>対称描画:</label>
              <input type="checkbox" id="live-symmetry-enabled" checked>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label>ペンの太さ:</label>
              <input type="range" id="pen-thickness-slider" min="0.5" max="50" step="0.1" value="2.0" style="width: 80px;">
              <span id="pen-thickness-value">2.0px</span>
            </div>
          </div>
          <div style="display: flex; gap: 10px; justify-content: center;">
            <button id="clear-live-canvas" class="demo-button">キャンバスをクリア</button>
            <button id="toggle-symmetry" class="demo-button">対称モード切替</button>
          </div>
        </div>
        
      </div>
      
      <div class="demo-section">
        <h2>🚀 Regl-Line Migration Test - Static Test Canvas</h2>
        <div style="text-align: center; margin: 20px 0;">
          <canvas id="test-canvas" width="1024" height="1024" style="max-width: 100%; height: auto; border: 2px solid #ddd; border-radius: 4px; background: white;"></canvas>
        </div>
        
        <!-- Renderer Selection -->
        <div style="text-align: center; margin: 20px 0; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px;">
          <h3 style="margin-top: 0; color: #856404;">🚀 レンダラー選択 - Regl-Line Migration Test</h3>
          <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin: 10px 0;">
            <label style="font-weight: bold;">レンダラー:</label>
            <select id="renderer-select" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px;">
              <option value="webgl">WebGL (従来型 - 1px制限)</option>
              <option value="regl-line" selected>Regl-Line (新型 - 太い線対応)</option>
            </select>
            <span id="renderer-status" style="font-size: 12px; color: #666;"></span>
          </div>
          <div id="renderer-info" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 10px 0; font-size: 12px; font-family: monospace;">
            <div><strong>現在のレンダラー:</strong> <span id="current-renderer-type">WebGL</span></div>
            <div><strong>太い線サポート:</strong> <span id="thick-line-support">❌ No</span></div>
            <div><strong>線幅範囲:</strong> <span id="line-width-range">1px - 1px</span></div>
            <div><strong>機能:</strong> <span id="renderer-features">Loading...</span></div>
          </div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
          <button id="render-all" class="demo-button">Render All Test Strokes</button>
          <button id="render-lines" class="demo-button">Render as Lines</button>
          <button id="render-points" class="demo-button">Render as Points</button>
          <button id="clear-canvas" class="demo-button">Clear Canvas</button>
        </div>
        
        <div style="text-align: center; margin: 20px 0; border-top: 2px solid #007bff; padding-top: 15px;">
          <h3>統合描画テスト</h3>
          
          <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center; justify-content: center; margin: 15px 0;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-weight: bold;">対称モード:</label>
              <input type="checkbox" id="symmetry-enabled" checked>
              <span>8軸対称ON/OFF</span>
            </div>
            
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-weight: bold;">色設定:</label>
              <select id="color-select" style="padding: 5px; border-radius: 3px; border: 1px solid #ddd;">
                <option value="black">黒</option>
                <option value="red">赤</option>
                <option value="blue">青</option>
                <option value="green">緑</option>
                <option value="orange">オレンジ</option>
                <option value="purple">紫</option>
              </select>
            </div>
          </div>
          
          <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 15px 0;">
            <button id="draw-line" class="demo-button">直線</button>
            <button id="draw-curve" class="demo-button">曲線</button>
            <button id="draw-arc" class="demo-button">円弧</button>
            <button id="draw-multi" class="demo-button">複数ストローク</button>
            <button id="draw-thick-line-demo" class="demo-button" style="background: #dc3545; border-color: #dc3545;">太い線デモ</button>
          </div>
        </div>
      </div>
      
      <div id="status" class="info">
        <h3>Status</h3>
        <p>Ready to test. Select renderer type and click buttons to test thick line rendering.</p>
      </div>
    </div>

    <script type="module">
        // Import our WebGL modules
        import { initializeRenderer, renderTestPattern, renderStrokes, renderStrokesAsPoints, 
                clearCanvas, setDrawingColor, renderStroke, cleanupRenderer } from './src/webgl/renderer.js';
        import { allTestStrokes, horizontalLineStroke, verticalLineStroke, diagonalLineStroke,
                arcStroke, complexCurveStroke, spiralStroke, zigzagStroke } from './src/data/testStrokes.js';
        // Import symmetry renderer
        import { renderStrokeWithSymmetry, renderStrokesWithSymmetry, generateSymmetricStrokes } from './src/symmetry/symmetryRenderer.js';
        // Import Paint App Factory
        import { PaintAppFactory } from './src/app/PaintAppFactory.js';
        // Import new renderer adapter system
        import { createRendererAdapter, getAvailableRendererTypes, compareRenderers } from './src/webgl/RendererAdapter.js';

        let renderer; // Legacy renderer (will be replaced by rendererAdapter)
        let rendererAdapter; // New unified renderer adapter
        let currentRendererType = 'regl-line';
        let paintApp;

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
            statusEl.innerHTML = `<h3>Status</h3><p style="color: ${type === 'error' ? '#721c24' : type === 'success' ? '#155724' : '#004085'};">${message}</p>`;
        }

        // Update renderer info display
        function updateRendererInfo() {
            if (!rendererAdapter) return;
            
            const info = rendererAdapter.getRendererInfo();
            const type = rendererAdapter.getRendererType();
            
            document.getElementById('current-renderer-type').textContent = 
                type === 'webgl' ? 'WebGL (従来型)' : 'Regl-Line (新型)';
            document.getElementById('thick-line-support').textContent = 
                info.supportsThickLines ? '✅ Yes' : '❌ No';
            document.getElementById('line-width-range').textContent = 
                `${info.lineWidthRange[0]}px - ${info.lineWidthRange[1]}px`;
            document.getElementById('renderer-features').textContent = 
                info.features.join(', ');
            
            // Update status display
            document.getElementById('renderer-status').textContent = 
                `(${info.supportsThickLines ? '太い線対応' : '1px制限'})`;
        }

        // Switch renderer type
        function switchRenderer(newType) {
            if (newType === currentRendererType) return;
            
            try {
                // Cleanup old renderer
                if (rendererAdapter) {
                    rendererAdapter.cleanup();
                }
                
                // Create new renderer adapter
                const canvas = document.getElementById('test-canvas');
                rendererAdapter = createRendererAdapter(canvas, newType);
                currentRendererType = newType;
                
                // Update UI
                updateRendererInfo();
                updateStatus(`Switched to ${newType} renderer`, 'success');
                
                // Clear canvas and update color
                rendererAdapter.clear();
                applyColorSetting();
                
                console.log(`🔄 Switched to ${newType} renderer`);
                
            } catch (error) {
                updateStatus(`Failed to switch renderer: ${error.message}`, 'error');
                console.error('Renderer switch error:', error);
            }
        }

        // 色設定を適用
        function applyColorSetting() {
            const colorSelect = document.getElementById('color-select');
            const colorName = colorSelect.value;
            
            const colors = {
                black: [0, 0, 0, 1],
                red: [1, 0, 0, 1],
                blue: [0, 0, 1, 1],
                green: [0, 1, 0, 1],
                orange: [1, 0.5, 0, 1],
                purple: [0.8, 0, 0.8, 1]
            };
            
            if (colors[colorName]) {
                // Use new renderer adapter if available, fallback to legacy renderer
                if (rendererAdapter) {
                    rendererAdapter.setDrawingColor(colors[colorName][0], colors[colorName][1], colors[colorName][2], colors[colorName][3]);
                } else if (renderer) {
                    setDrawingColor(renderer, colors[colorName][0], colors[colorName][1], colors[colorName][2], colors[colorName][3]);
                }
            }
        }

        // ストローク描画の統合関数
        function drawStroke(strokeType) {
            const activeRenderer = rendererAdapter || renderer;
            if (!activeRenderer) {
                updateStatus('エラー: レンダラーが初期化されていません', 'error');
                return;
            }

            // 色設定を適用
            applyColorSetting();
            
            // 対称モード設定を取得
            const symmetryEnabled = document.getElementById('symmetry-enabled').checked;
            const symmetryConfig = {
                enabled: symmetryEnabled,
                axisCount: 8,
                centerPoint: { x: 512, y: 512 }
            };

            let strokes = [];
            
            // ストロークタイプに応じてデータを生成
            switch (strokeType) {
                case 'line':
                    strokes = [horizontalLineStroke];
                    break;
                    
                case 'curve':
                    strokes = [complexCurveStroke];
                    break;
                    
                case 'arc':
                    strokes = [arcStroke];
                    break;
                    
                case 'multi':
                    strokes = [horizontalLineStroke, diagonalLineStroke];
                    break;
            }

            try {
                // Use renderer adapter if available
                if (rendererAdapter) {
                    rendererAdapter.clear();
                    if (symmetryEnabled) {
                        // Manual symmetry rendering for renderer adapter
                        for (const stroke of strokes) {
                            const symmetricStrokes = generateSymmetricStrokes(stroke, symmetryConfig).symmetricStrokes;
                            for (const symStroke of symmetricStrokes) {
                                rendererAdapter.renderStroke(symStroke);
                            }
                        }
                        updateStatus(`✓ ${strokeType}描画完了（8軸対称モード）- ${strokes.length}個のストロークから${strokes.length * 8}個の対称ストロークを生成 [${currentRendererType}]`, 'success');
                    } else {
                        rendererAdapter.renderStrokes(strokes);
                        updateStatus(`✓ ${strokeType}描画完了（通常モード）- ${strokes.length}個のストロークを描画 [${currentRendererType}]`, 'success');
                    }
                } else {
                    // Fallback to legacy renderer
                    clearCanvas(renderer);
                    if (symmetryEnabled) {
                        renderStrokesWithSymmetry(renderer, strokes, symmetryConfig);
                        updateStatus(`✓ ${strokeType}描画完了（8軸対称モード）- ${strokes.length}個のストロークから${strokes.length * 8}個の対称ストロークを生成`, 'success');
                    } else {
                        renderStrokes(renderer, strokes);
                        updateStatus(`✓ ${strokeType}描画完了（通常モード）- ${strokes.length}個のストロークを描画`, 'success');
                    }
                }
            } catch (error) {
                console.error('描画エラー:', error);
                updateStatus('エラー: 描画に失敗しました - ' + error.message, 'error');
            }
        }

        function initializeDemo() {
            try {
                // TEMPORARILY DISABLE legacy renderer to avoid interference
                console.log('⚠️ Legacy renderer temporarily disabled to avoid regl-line interference');
                // renderer = initializeRenderer('test-canvas');
                // setDrawingColor(renderer, 0.0, 0.0, 0.0, 1.0);
                
                // Initialize new renderer adapter system (only regl-line)
                const canvas = document.getElementById('test-canvas');
                rendererAdapter = createRendererAdapter(canvas, currentRendererType);
                updateRendererInfo();
                
                // Initialize interactive paint app
                paintApp = PaintAppFactory.create({
                    canvasId: 'paint-canvas',
                    displaySize: { width: 500, height: 500 },
                    enableDebug: true
                });
                
                
                updateStatus('WebGL renderer, Regl-Line adapter, and Paint App initialized successfully. Both canvases ready!', 'success');
                
            } catch (error) {
                updateStatus(`Failed to initialize: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Button event handlers - Updated to use renderer adapter
        document.getElementById('render-all').addEventListener('click', () => {
            try {
                if (rendererAdapter) {
                    rendererAdapter.clear();
                    rendererAdapter.renderStrokes(allTestStrokes);
                    updateStatus(`Rendered all test strokes (${allTestStrokes.length} strokes) [${currentRendererType}]`, 'success');
                } else {
                    renderTestPattern(renderer, allTestStrokes);
                    updateStatus(`Rendered all test strokes (${allTestStrokes.length} strokes) [legacy]`, 'success');
                }
            } catch (error) {
                updateStatus(`Error rendering all strokes: ${error.message}`, 'error');
            }
        });

        document.getElementById('render-lines').addEventListener('click', () => {
            try {
                if (rendererAdapter) {
                    rendererAdapter.clear();
                    rendererAdapter.renderStrokes(allTestStrokes);
                    updateStatus(`Rendered ${allTestStrokes.length} strokes as line strips [${currentRendererType}]`, 'success');
                } else {
                    clearCanvas(renderer);
                    renderStrokes(renderer, allTestStrokes);
                    updateStatus(`Rendered ${allTestStrokes.length} strokes as line strips [legacy]`, 'success');
                }
            } catch (error) {
                updateStatus(`Error rendering lines: ${error.message}`, 'error');
            }
        });

        document.getElementById('render-points').addEventListener('click', () => {
            try {
                if (rendererAdapter) {
                    rendererAdapter.clear();
                    rendererAdapter.setDrawingColor(1.0, 0.0, 0.0, 1.0); // Red points
                    rendererAdapter.renderStrokesAsPoints(allTestStrokes);
                    updateStatus(`Rendered all strokes as red points [${currentRendererType}]`, 'success');
                } else {
                    clearCanvas(renderer);
                    setDrawingColor(renderer, 1.0, 0.0, 0.0, 1.0); // Red points
                    renderStrokesAsPoints(renderer, allTestStrokes);
                    updateStatus('Rendered all strokes as red points [legacy]', 'success');
                }
            } catch (error) {
                updateStatus(`Error rendering points: ${error.message}`, 'error');
            }
        });

        document.getElementById('clear-canvas').addEventListener('click', () => {
            try {
                if (rendererAdapter) {
                    rendererAdapter.clear();
                    updateStatus(`Canvas cleared [${currentRendererType}]`, 'success');
                } else {
                    clearCanvas(renderer);
                    updateStatus('Canvas cleared [legacy]', 'success');
                }
            } catch (error) {
                updateStatus(`Error clearing canvas: ${error.message}`, 'error');
            }
        });

        // Renderer selection event handler
        document.getElementById('renderer-select').addEventListener('change', (e) => {
            const newType = e.target.value;
            switchRenderer(newType);
        });

        // Thick line demo function
        function drawThickLineDemo() {
            if (!rendererAdapter) {
                updateStatus('エラー: レンダラーアダプターが初期化されていません', 'error');
                return;
            }
            
            try {
                rendererAdapter.clear();
                
                // Create thick line demo strokes with various sizes
                const thickLineDemoStrokes = [
                    // 1px line (baseline)
                    {
                        id: 'thick-demo-1px',
                        points: [
                            { x: 100, y: 100, pressure: 1.0, timestamp: Date.now() },
                            { x: 400, y: 100, pressure: 1.0, timestamp: Date.now() + 10 }
                        ],
                        timestamp: Date.now(),
                        completed: true
                    },
                    // 5px line
                    {
                        id: 'thick-demo-5px',
                        points: [
                            { x: 100, y: 200, pressure: 1.0, timestamp: Date.now() },
                            { x: 400, y: 200, pressure: 1.0, timestamp: Date.now() + 10 }
                        ],
                        timestamp: Date.now(),
                        completed: true
                    },
                    // 15px line
                    {
                        id: 'thick-demo-15px',
                        points: [
                            { x: 100, y: 300, pressure: 1.0, timestamp: Date.now() },
                            { x: 400, y: 300, pressure: 1.0, timestamp: Date.now() + 10 }
                        ],
                        timestamp: Date.now(),
                        completed: true
                    },
                    // 25.2px line (the problematic size from migration plan)
                    {
                        id: 'thick-demo-25.2px',
                        points: [
                            { x: 100, y: 400, pressure: 1.0, timestamp: Date.now() },
                            { x: 400, y: 400, pressure: 1.0, timestamp: Date.now() + 10 }
                        ],
                        timestamp: Date.now(),
                        completed: true
                    }
                ];
                
                const sizes = [1, 5, 15, 25.2];
                const colors = [
                    [0, 0, 0, 1],      // Black
                    [1, 0, 0, 1],      // Red  
                    [0, 0, 1, 1],      // Blue
                    [1, 0.5, 0, 1]     // Orange
                ];
                
                // Draw each stroke with different thickness
                thickLineDemoStrokes.forEach((stroke, index) => {
                    rendererAdapter.setBrushSize(sizes[index]);
                    rendererAdapter.setDrawingColor(colors[index][0], colors[index][1], colors[index][2], colors[index][3]);
                    rendererAdapter.renderStroke(stroke);
                });
                
                const rendererType = rendererAdapter.getRendererType();
                const supportsThick = rendererAdapter.getRendererInfo().supportsThickLines;
                
                if (supportsThick) {
                    updateStatus(
                        `✅ 太い線デモ完了 [${rendererType}]: 1px(黒), 5px(赤), 15px(青), 25.2px(オレンジ) - 全て正しい太さで描画`, 
                        'success'
                    );
                } else {
                    updateStatus(
                        `⚠️ 太い線デモ完了 [${rendererType}]: 1px(黒), 5px(赤), 15px(青), 25.2px(オレンジ) - WebGL制限により全て1pxで描画`, 
                        'success'
                    );
                }
            } catch (error) {
                console.error('太い線デモエラー:', error);
                updateStatus('エラー: 太い線デモに失敗しました - ' + error.message, 'error');
            }
        }

        // 統合描画ボタン
        document.getElementById('draw-line').addEventListener('click', () => drawStroke('line'));
        document.getElementById('draw-curve').addEventListener('click', () => drawStroke('curve'));
        document.getElementById('draw-arc').addEventListener('click', () => drawStroke('arc'));
        document.getElementById('draw-multi').addEventListener('click', () => drawStroke('multi'));
        document.getElementById('draw-thick-line-demo').addEventListener('click', drawThickLineDemo);

        // Live canvas controls
        document.getElementById('clear-live-canvas').addEventListener('click', () => {
            if (paintApp) {
                paintApp.clearCanvas();
                updateStatus('Live canvas cleared', 'success');
            }
        });

        // Simplified live canvas controls  
        document.getElementById('toggle-symmetry').addEventListener('change', (e) => {
            if (paintApp) {
                paintApp.updateSymmetry(e.target.checked, 8);
            }
        });

        document.getElementById('live-symmetry-enabled').addEventListener('change', (e) => {
            if (paintApp) {
                paintApp.updateSymmetry(e.target.checked, 8);
            }
        });

        // Pen thickness slider
        const penThicknessSlider = document.getElementById('pen-thickness-slider');
        const penThicknessValue = document.getElementById('pen-thickness-value');
        
        if (penThicknessSlider) {
            penThicknessSlider.addEventListener('input', (e) => {
                const thickness = parseFloat(e.target.value);
                penThicknessValue.textContent = `${thickness}px`;
                if (paintApp) {
                    paintApp.setBrushSize(thickness);
                }
            });
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeDemo);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (rendererAdapter) {
                rendererAdapter.cleanup();
            }
            if (renderer) {
                cleanupRenderer(renderer);
            }
            if (paintApp) {
                paintApp.destroy();
            }
        });
    </script>
  </body>
</html>
